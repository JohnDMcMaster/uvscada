#include <unistd.h>
#include "TEMPer.h"

void I2CDelay() {
	usleep(1000);
}

//Common between SPI and I2C
void Sclk(int a) {
	//Pin is inverted
	DTR(a == 0);
}

void SDout(int in) {
	//Pin is inverted
	RTS(!in);
}

/*
void SDoutBit(unsigned int bit) {
	//Pin is inverted
	RTS(!bit);
}
*/

int SDin(void) {
	//Make sure that we aren't driving it low
	SDout(1);
	I2CDelay();
	return !CTS();
}

void HiLowSCLK(void) {
	//Delay(10);
	I2CDelay();
	Sclk(1);
	//Delay(20);
	I2CDelay();
	Sclk(0);
	//Delay(20);
	I2CDelay();
}

uint8_t ReadACKMine()
{
	//Assume clock was low at start
	uint8_t tt = SDin();
	HiLowSCLK();
	return tt;
}

//http://www.lammertbies.nl/comm/info/I2C-bus.html#star
void I2CStart(void) {
	/*
	To create a START condition, the clock line SCL remains high, while the master changes the SDA line to the low condition.	
	SDA  UUU========________	
	SCL  UUUUUUU========____
	*/
	
	//Prereq state
	SDout(1);
	//Delay(4);
	I2CDelay();
	Sclk(1);
	//Delay(40);
	I2CDelay();

	//Changing SDA low while SCL is high is the start condition
	SDout(0);
	//Delay(30);
	I2CDelay();
	
	//Code will expect SCL low so that we can set data
	//Otherwise we might send a stop condition by mistake
	Sclk(0);
	//Delay(30);
	I2CDelay();
}

void I2CStop(void) {
	/*
	The end of a communication session is signaled by a STOP condition. 
	The STOP condition is generated by changing the SDA data line to high while the clock line SCL is high.

	We assume SCL was brought low by the previous transmit finishing
	SDA  UUU______===
	SCL  UUUUUU======
	*/
	
	//Prereq state
	SDout(0);
	//Delay(50);
	I2CDelay();
	Sclk(1);
	//Delay(50);
	I2CDelay();
	
	//Bring it high to issue the stop condition
	SDout(1);
	//Delay(50);
	I2CDelay();
}

//Clock should be low at start
void I2CWriteByte(uint8_t byte) {
	printf_debug("I2C: write byte 0x%02X\n", byte);
	//MSB first
	unsigned int mask = 0x80;
	for( ;; )
	{
		SDout(byte & mask);
		HiLowSCLK();
		
		if( mask == 0x01 )
		{
			break;
		}
		mask = mask >> 1;
	}
	//Stop pulling line low
	//SDout( 1 );
}

uint8_t I2CReadByte( void ) {
	//Clock should be low before and after calling
	uint8_t byte = 0;
	//MSB first
	unsigned int mask = 0x80;
	
	//Stop pulling line low
	SDout( 1 );
	//Delay(20);
	I2CDelay();
	
	for( ;; )
	{
		//Data is valid when clock is high
		Sclk(1);
		//Delay(100);
		I2CDelay();
		if( SDin() )
		{
			byte += mask;
		}
		Sclk(0);
		//Delay(100);
		I2CDelay();
		
		if( mask == 0x01 )
		{
			break;
		}
		mask = mask >> 1;
	}
	printf_debug("read byte 0x%02X\n", byte);
	return byte;
}	

int I2CWaitACK() {
	int ret;
	//Make sure we aren't bringing the line low
	SDout(1);
	//Delay(100);
	I2CDelay();
	Sclk(1);
	//Delay(100);
	I2CDelay();
	ret = SDin();
	Sclk(0);
	I2CDelay();
	return ret;
}

void I2CScan() {
	/*
	Device at 0x9E
		FM75
	Device at 0xA0
		24C02
	*/
	for( int i = 0; i < 256; i += 2 ) 
	{
		I2CStart();
		//Dummy write
		I2CWriteByte(I2C_ADDRESS(i, I2C_WRITE));
		//Requires longer delay than others...why?
		usleep(1000);
		//Set to 0 if someone brought it low
		if( ReadACKMine() == 0 ) 
		{
			printf("Device at 0x%02X\n", i);
		}
	}
}

#if 0
//verified does work as expected on 24C02
void hilosda( void ) {
	for (;;) {
		printf("off\n");
		SDout(0);
		debug_sleep(3);

		printf("on\n");
		SDout(1);
		debug_sleep(3);
	}
}

//Verified works as expected on 24C02 and MAX6675
void hiloscl( void ) {
	for (;;) {
		printf("off\n");
		Sclk(0);
		debug_sleep(3);

		printf("on\n");
		Sclk(1);
		debug_sleep(3);
	}
}

//Verified is setting CS as expected
void hiloCS( void ) {
	for (;;) {
		printf("CS off\n");
		CS(0);
		debug_sleep(3);

		printf("CS on\n");
		CS(1);
		debug_sleep(3);
	}
}
#endif

